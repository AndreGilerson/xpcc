// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------

#ifndef XPCC_{{target.family | upper}}_SIMPLE_UART_SPI{{id}}_HPP
#	error	"Don't include this file directly, use 'uart_simple_spi.hpp' instead!"
#endif

// ----------------------------------------------------------------------------
template< class clockSource, uint32_t baudrate, uint16_t tolerance >
void
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::initialize()
{
	// calculate the fractional prescaler value
	constexpr float pre_raw = static_cast<float>(clockSource::UsartSpi) / ( 2 * baudrate );
	// respect the prescaler range of 1 to 4096
	constexpr uint32_t pre_ceil = std::ceil(pre_raw) > 4096 ? 4096 : std::ceil(pre_raw);
	constexpr uint32_t pre_floor = std::floor(pre_raw) < 1 ? 1 : std::floor(pre_raw);

	// calculate the possible baudrates above and below the requested baudrate
	constexpr uint32_t baud_lower = clockSource::UsartSpi / ( 2 * pre_ceil );
	constexpr uint32_t baud_upper = clockSource::UsartSpi / ( 2 * pre_floor );

	// calculate the fractional prescaler value corresponding to the baudrate exactly
	// between the upper and lower baudrate
	constexpr float pre_middle = static_cast<float>(clockSource::UsartSpi) /
			( 2 * ((baud_upper - baud_lower) / 2.f + baud_lower) );
	// decide which prescaler value is closer to a possible baudrate
	constexpr uint16_t prescaler = (pre_raw >= pre_middle) ? pre_ceil : pre_floor;

	// check if within baudrate tolerance
	constexpr uint32_t generated_baudrate = clockSource::UsartSpi / (2 * prescaler);
	assertBaudrateInTolerance<
		/* clostest available baudrate */ generated_baudrate,
		/* desired baudrate */ baudrate,
		tolerance >();

	initialize(prescaler - 1);
}

void
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::setDataMode(DataMode mode)
{
%% if extended is defined
	UCSR{{ id }}C = (UCSR{{ id }}C & ~((1 << UCPOL{{ id }}) | (1 << UCPHA{{ id }}))) | static_cast<uint8_t>(mode);
%% else
	UCSR{{ id }}C = (UCSR{{ id }}C & ~(1 << UCPOL{{ id }})) | static_cast<uint8_t>(mode);
%% endif
}

void
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::setDataOrder(DataOrder order)
{
%% if extended is defined
	UCSR{{id}}C = (UCSR{{id}}C & ~(1 << UDORD{{id}})) | static_cast<uint8_t>(order);
%% else
	dataOrder = order;
%% endif
}

// ----------------------------------------------------------------------------
%% if extended is defined
uint8_t
xpcc::{{target.family}}::UartSpiSimpleMaster{{id}}::writeReadBlocking(uint8_t data)
{
	while(!((UCSR{{id}}A & (1 << UDRE{{id}}))))
		;

	UDR{{id}} = data;

	while (!((UCSR{{id}}A & (1 << RXC{{id}}))))
		;

	data = UDR{{id}};

	return data;
}
%% endif
