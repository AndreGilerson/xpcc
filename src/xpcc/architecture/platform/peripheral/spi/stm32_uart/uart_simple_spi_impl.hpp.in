// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------

#ifndef XPCC_STM32_UART_SIMPLE_SPI{{ id }}_HPP
#	error	"Don't include this file directly, use 'uart_simple_spi.hpp' instead!"
#endif

template<class clockSource, uint32_t baudrate, uint16_t tolerance >
void ALWAYS_INLINE
xpcc::stm32::UartSpiSimpleMaster{{ id }}::initialize()
{
	constexpr UartBase::OversamplingMode oversample =
			UartBaudrate::getOversamplingMode(clockSource::Usart{{ id }}, baudrate);

	UsartHal{{ id }}::initializeWithBrr(
			UartBaudrate::getBrr<clockSource::Usart{{ id }}, baudrate, tolerance>(),
			UsartHal{{ id }}::Parity::Disabled,
			oversample);

	UsartHal{{ id }}::setLastBitClockPulse(UsartHal{{ id }}::LastBitClockPulse::Output);
	UsartHal{{ id }}::setSpiClock(UsartHal{{ id }}::SpiClock::Enabled);
	UsartHal{{ id }}::setTransmitterEnable(true);
	UsartHal{{ id }}::setReceiverEnable(true);
	dataOrder = DataOrder::MsbFirst;
}

void ALWAYS_INLINE
xpcc::stm32::UartSpiSimpleMaster{{ id }}::setDataMode(DataMode mode)
{
	UsartHal{{ id }}::setSpiDataMode(static_cast<UartBase::SpiDataMode>(mode));
}

void ALWAYS_INLINE
xpcc::stm32::UartSpiSimpleMaster{{ id }}::setDataOrder(DataOrder order)
{
	dataOrder = order;
}
