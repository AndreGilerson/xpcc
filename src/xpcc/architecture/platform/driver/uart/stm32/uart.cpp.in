// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
{{ generation_block }}

%% if id in [1, 2, 3, 6]
%%	set uart = "Usart"
%% elif id in [4, 5]
%%	set uart = "Uart"
%% endif
%#
%% set name = uart ~ id
%% set hal = uart ~ "Hal" ~ id

#include "../../../device.hpp"
#include "{{ uart | lower }}_hal_{{ id }}.hpp"
#include "{{ uart | lower }}_{{ id }}.hpp"

#include <xpcc/architecture/driver/atomic.hpp>
#include <xpcc/architecture/driver/function.hpp>

namespace
{
	static const uint8_t *txBuffer(nullptr);
	static std::size_t txSize(0);

	static uint8_t *rxBuffer(nullptr);
	static std::size_t rxSize(0);

	static xpcc::Uart::CompletionHandler writeCompletionHandler(xpcc::IgnoreStaticConstructor);
	static xpcc::Uart::CompletionHandler  readCompletionHandler(xpcc::IgnoreStaticConstructor);
}

bool
xpcc::stm32::{{ name }}::write(const uint8_t *data, std::size_t length)
{
	if (txSize > 0 or data == nullptr or length == 0)
		return false;

	atomic::Lock lock;

	{{ hal }}::enableInterrupt(Interrupt::TxEmpty);
	{{ hal }}::write(*data);

	txBuffer = data + 1;
	txSize = length - 1;

	return true;
}

bool
xpcc::stm32::{{ name }}::isWriteFinished()
{
	return (txSize == 0) and {{ hal }}::isTransmitRegisterEmpty();
}

std::size_t
xpcc::stm32::{{ name }}::discardWriteBuffer()
{
	// disable interrupt since buffer will be cleared
	{{ hal }}::disableInterrupt({{ hal }}::Interrupt::TxEmpty);
	std::size_t count = txSize;
	txSize = 0;
	return count;
}

void
xpcc::stm32::{{ name }}::attachWriteCompletionHandler(CompletionHandler handler)
{
	atomic::Lock lock;
	writeCompletionHandler = handler;
}

bool
xpcc::stm32::{{ name }}::read(uint8_t *data, std::size_t length)
{
	if (rxSize > 0 or data == nullptr or length == 0)
		return false;

	atomic::Lock lock;

	rxBuffer = data;
	rxSize = length;

	{{ hal }}::enableInterrupt({{ hal }}::Interrupt::RxNotEmpty);
	return true;
}

bool
xpcc::stm32::{{ name }}::isReadFinished()
{
	return (rxSize == 0);
}

std::size_t
xpcc::stm32::{{ name }}::discardReadBuffer()
{
	std::size_t count = rxSize;

	atomic::Lock lock;
	rxSize = 0;
	{{ hal }}::disableInterrupt({{ hal }}::Interrupt::TxEmpty);
	return count;
}

void
xpcc::stm32::{{ name }}::attachReadCompletionHandler(CompletionHandler handler)
{
	atomic::Lock lock;
	readCompletionHandler = handler;
}

%% set hal = "xpcc::stm32::" ~ hal
extern "C" void
{{ uart | upper ~ id }}_IRQHandler()
{
	if ({{ hal }}::isReceiveRegisterNotEmpty())
	{
		// TODO: save the errors
		if (rxSize > 0) {
			{{ hal }}::read(*rxBuffer);
			rxBuffer++;
			rxSize--;
		} else {
			{{ hal }}::disableInterrupt({{ hal }}::Interrupt::RxNotEmpty);
			if (not readCompletionHandler.empty()) {
				readCompletionHandler();
			}
		}
	}
	if ({{ hal }}::isTransmitRegisterEmpty())
	{
		if (txSize > 0) {
			{{ hal }}::write(*txBuffer);
			txBuffer++;
			txSize--;
		} else {
			// transmission finished, disable TxEmpty interrupt
			{{ hal }}::disableInterrupt({{ hal }}::Interrupt::TxEmpty);
			if (not writeCompletionHandler.empty()) {
				writeCompletionHandler();
			}
		}
	}
}
