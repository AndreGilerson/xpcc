#!/usr/bin/env python2
# 
# Copyright (c) 2016, Roboterclub Aachen e. V.
# All Rights Reserved.
#
# The file is part of the xpcc library and is released under the 3-clause BSD
# license. See the file `LICENSE` for the full license governing this code.

import os
import sys
import string
from time import sleep

import logging

import subprocess
import yaml

import hwut.verifier.periodic_square_wave as psw
# import hwut.openocd as openocd
import hwut.acquirer_sigrok as acquirer_sigrok
import hwut.decoder_sigrok as decoder_sigrok

import ext.pythongdbmi.gdbmi.session as gdbmi

logging.basicConfig(
    level=logging.INFO,
    # level=logging.DEBUG,
    format='%(asctime)-15s '\
        '%(levelname)-8s '\
        '%(filename)18s:%(lineno)-4s '\
        '%(message)s')


class Target(object):
	def __init__(self, debuggee, gdb="arm-none-eabi-gdb"):
		self.s = gdbmi.Session(debuggee, gdb=gdb)

	def prepare(self, label='hwut_begin'):
		logging.debug('Target: Preparing')
		token = self.s.target_select_remote()
		while not self.s.wait_for(token): pass

		token = self.s.monitor_reset_halt()
		while not self.s.wait_for(token): pass

		# Target is at ResetHandler

		self.advance('hwut_begin')

		self.wait_for_stop()
		logging.debug('Target: Prepared')


	def advance(self, label):
		logging.debug('Target: Advancing to %s' % label)
		token = self.s.exec_advance(label)

		while not self.s.wait_for(None):
			if self.s.exec_state == "running":
				break

	def wait_for_stop(self):
		while not self.s.wait_for(None):
			if self.s.exec_state == "stopped":
				break
		logging.debug('Target: Stopped')


Import('env')

logging.info('===== Welcome to HWUT =====')

tests = {
	'stm32l476disco1': {
		'path': 'hwut/stm32l476disco1', 
		'stimuli': None, 
		'output': 'disco1.output' 
		},
	'stm32l476disco2': {
		'path': 'hwut/stm32l476disco1', 
		'stimuli': 'mystimuli', 
		'output': 'disco2.output' 
		},
	'stm32l476nucleo1': {
		'path': 'hwut/stm32l476nucleo1',
		'stimuli': None,
		'output': 'nucleo1.output'
	}
}

hwut = 'all' if 'hwut' in BUILD_TARGETS else ARGUMENTS.get('hwut')

if not tests.has_key(hwut):
	logging.error('\nFAIL! %s is not in list of test.\nValid tests are:\n%s' % (hwut, '\n'.join(x for x in tests.keys())))
	Exit(1)
else:
	test = tests[hwut]

result = []
everythingOk = True

if str(Platform()) != "win32":
	color_red = "\033[0;31m"
	color_green = "\033[0;32m"
	color_yellow = "\033[0;33m"
	color_default = "\033[0m"
else:
	color_red = ""
	color_green = ""
	color_yellow = ""
	color_default = ""

for path, directories, files in os.walk(test['path']):
	if 'SConstruct' in files:

		# Find and open the hwut.cfg
		hwut_cfg = os.path.abspath(os.path.join(path, 'hwut.cfg'))

		if os.path.isfile(hwut_cfg):
			y = yaml.load(open(hwut_cfg))
		else:
			logging.error('%s is missing' % hwut_cfg)
			Exit(1)


		# Build and program project with scons
		action = [] # ['build', 'program']
		for act in action:
			if not everythingOk:
				continue

			exitStatus = os.system("scons -Q -C %s %s" % (path, act))
			if exitStatus == 0:
				result.append("%s: %s -> Ok" % (path, act))
			else:
				result.append(color_red + ("%s: %s -> FAIL!" % (path, act)) + color_default)
				everythingOk = False

		logging.info('About to start test suite %s ...' % hwut)

		if y['acquirer']['name'] == 'sigrok':
			acquirer = acquirer_sigrok.SigrokAcquirer(y['acquirer'])

		target = Target(debuggee = "/Users/usr/Dev/2016imr/xpcc/build/stm32l476_discovery/stm32l476disco1/stm32l476disco1.elf")
		target.prepare()
		
		# CPU just before first test

		for test in y['tests']:
			logging.info('=== Starting test %s ===' % test['name'])

			# Start the acquirer
			logging.info('--- Start Acquirer %s ---' % y['acquirer']['name'])
			acquirer.start(test['acquirer'])

			# Start target and run until end of this test
			target.advance(test['name'] + '_end')

			# Wait for normal termination or kill acquirer
			if not acquirer.waitForCompletion():
				logging.error('Acquiring failed')
				Exit(1)

			logging.info('--- Waiting for target to stop ---')
			target.wait_for_stop()
			logging.info('--- Target stopped ---')

			sroutfile = acquirer.getOutputFilename()


			# Decode
			decoder = decoder_sigrok.SigrokDecoder()
			decoder.decode(test['decoder'], sroutfile)


			# Verify trace
			srdecodefile = decoder.getOutputFilename()

			with open(srdecodefile) as fp:
				trace = fp.readlines()

			for (verifier, config) in test['verifier'].iteritems():
				if verifier == 'PeriodicSquareWave':
					v = psw.PeriodicSquareWave(config)
				elif verifier == 'String':
					continue

				everythingOk &= v.verify(trace)

				logging.info('--- Verifier Report ---')
				for l in v.getReport():
					logging.info(l)

			if everythingOk:
				result.append("%s -> Ok" % test['name'])
			else:
				result.append("%s -> FAIL!" % test['name'])

			# Cleanup
			acquirer.close()
			decoder.close()

			logging.info('=== Test %s ended ===' % test['name'])

		target.advance('hwut_end')
		target.wait_for_stop()

logging.info("###### FINAL RESULTS ######")
for line in result:
	logging.info(line)
if everythingOk:
	logging.info("OK!")
	Exit(0)
else:
	logging.error("FAIL!")
	Exit(1)
